package org.ntnu.idi.idatt2105.fant.org.fantorg.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotNull;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import lombok.*;
import org.ntnu.idi.idatt2105.fant.org.fantorg.model.enums.Role;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

/**
 * Represents a user of the system, encapsulating all personal and authentication details. This
 * class implements the {@link UserDetails} interface from Spring Security to integrate
 * authentication and authorization functionalities seamlessly.
 *
 * @author Harry Xu
 * @since 1.0
 */
@Builder
@NoArgsConstructor
@Entity
@Getter
@Setter
@AllArgsConstructor
@Table(name = "\"USER\"")
public class User implements UserDetails {

  /** The unique identifier for the user, automatically generated by the database. */
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  @Setter(AccessLevel.NONE)
  private Long id;

  /** First name of the user; cannot be null. */
  @NotNull
  @Column(nullable = false)
  private String firstName;

  /** Last name of the user; cannot be null. */
  @NotNull
  @Column(nullable = false)
  private String lastName;

  /** Encrypted password for user authentication; cannot be null. */
  @NotNull
  @Column(nullable = false)
  private String password;

  /** User's email address, must be valid as per the @Email constraint; unique across users. */
  @NotNull
  @Column(nullable = false, unique = true)
  @Email
  private String email;

  /** User's address, can be null. */
  private String address;

  /** User's phone number, can be null. */
  private String number;

  /**
   * A user's role. The role determines the user's level of access. See {@link Role} for available
   * roles.
   */
  @NotNull
  @Column(nullable = false)
  @Enumerated
  private Role role;

  /**
   * Returns the granted authorities for the user based on their role. This method integrates with
   * Spring Security for role-based access control.
   *
   * @return a collection of granted authorities for the user's role.
   */
  @Override
  public Collection<? extends GrantedAuthority> getAuthorities() {
    return List.of(new SimpleGrantedAuthority("ROLE_" + role.name()));
  }

  /**
   * One-to-many relationship between user and items that they have listed for sale. When a user is
   * removed, the corresponding items are also removed due to cascade settings.
   */
  @OneToMany(mappedBy = "seller", cascade = CascadeType.REMOVE, orphanRemoval = true)
  private List<Item> items;

  /**
   * One-to-many relationship between user and their bookmarks. When a user is removed, the
   * corresponding bookmarks are also removed.
   */
  @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
  private Set<Bookmark> bookmarks = new HashSet<>();

  /**
   * One-to-many relationship between user and their notifications. When a user is removed, the
   * corresponding notifications are also removed.
   */
  @OneToMany(mappedBy = "recipient", cascade = CascadeType.ALL, orphanRemoval = true)
  private List<Notification> notifications = new ArrayList<>();

  /**
   * One-to-many relationship between user and received chat messages. When a user is removed, the
   * corresponding messages are also removed.
   */
  @OneToMany(mappedBy = "recipient", cascade = CascadeType.ALL, orphanRemoval = true)
  private List<ChatMessage> chatMessagesRecipient = new ArrayList<>();

  /**
   * One-to-many relationship between user and sent chat messages. When a user is removed, the
   * corresponding messages are also removed.
   */
  @OneToMany(mappedBy = "sender", cascade = CascadeType.ALL, orphanRemoval = true)
  private List<ChatMessage> chatMessagesSender = new ArrayList<>();

  /**
   * One-to-many relationship between user and the chat rooms they belong to as a recipient. When a
   * user is removed, the corresponding chat rooms are also removed.
   */
  @OneToMany(mappedBy = "recipient", cascade = CascadeType.ALL, orphanRemoval = true)
  private List<ChatRoom> chatRoomRecipient = new ArrayList<>();

  /**
   * One-to-many relationship between user and the chat rooms they belong to as a sender. When a
   * user is removed, the corresponding chat rooms are also removed.
   */
  @OneToMany(mappedBy = "sender", cascade = CascadeType.ALL, orphanRemoval = true)
  private List<ChatMessage> chatRoomSender = new ArrayList<>();

  /**
   * A one-to-one relationship between a user and their profile image. The profile image is linked
   * to the user, and can be updated or removed.
   */
  @OneToOne
  @JoinColumn(name = "profile_image_id")
  private Image profileImage;

  /**
   * One-to-one relationship between user and their refresh token. This refresh token is used for
   * session management and authentication.
   */
  @OneToOne(
      mappedBy = "user",
      cascade = CascadeType.ALL,
      orphanRemoval = true,
      fetch = FetchType.LAZY)
  private RefreshToken refreshToken;

  /**
   * Retrieves the username of the user. In this case, the email is used as the username. This
   * method is required by the Spring Security {@link UserDetails} interface.
   *
   * @return the email address of the user.
   */
  @Override
  public String getUsername() {
    return this.email;
  }

  /**
   * Always returns true, indicating that the account is not expired.
   *
   * @return true, as the account is always considered non-expired.
   */
  @Override
  public boolean isAccountNonExpired() {
    return true;
  }

  /**
   * Always returns true, indicating that the account is not locked.
   *
   * @return true, as the account is always considered non-locked.
   */
  @Override
  public boolean isAccountNonLocked() {
    return true;
  }

  /**
   * Always returns true, indicating that the credentials are not expired.
   *
   * @return true, as the credentials are always considered non-expired.
   */
  @Override
  public boolean isCredentialsNonExpired() {
    return true;
  }

  /**
   * Always returns true, indicating that the account is enabled.
   *
   * @return true, as the account is always considered enabled.
   */
  @Override
  public boolean isEnabled() {
    return true;
  }

  /**
   * Retrieves the password of the user. This method is required by the Spring Security {@link
   * UserDetails} interface.
   *
   * @return the password of the user.
   */
  @Override
  public String getPassword() {
    return password;
  }
}
